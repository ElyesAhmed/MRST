
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>injector_producer_array</title><meta name="generator" content="MATLAB 8.2"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-12-04"><meta name="DC.source" content="injector_producer_array.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">add the necessary modeules</a></li><li><a href="#3">Define the domain</a></li><li><a href="#4">Define the rock</a></li><li><a href="#5">Define the fluid</a></li><li><a href="#6">Define the chemistry</a></li><li><a href="#7">solve the chemistry for the initial and injected compositions</a></li><li><a href="#8">Define the transport model</a></li><li><a href="#9">Define the boundary conditions</a></li><li><a href="#10">Define the time stepping schedule</a></li><li><a href="#11">Run the simulation</a></li><li><a href="#12">visualize the simulation</a></li><li><a href="#13">Copyright notice</a></li></ul></div><pre class="codeinput">close <span class="string">all</span>;
clear;
</pre><h2>add the necessary modeules<a name="2"></a></h2><pre class="codeinput">mrstModule <span class="string">add</span> <span class="string">ad-core</span> <span class="string">ad-props</span> <span class="string">ad-blackoil</span> <span class="string">geochemistry</span> <span class="string">mrst-gui</span>
mrstVerbose <span class="string">off</span>
</pre><h2>Define the domain<a name="3"></a></h2><p>here we look at a cartesian grid  with 100 cells</p><pre class="codeinput">sideLength = 10;
G = cartGrid([sideLength, sideLength, 1], [sideLength, sideLength, 1]);
G = computeGeometry(G);
nc = G.cells.num;

<span class="comment">% you can view the domain using plotGrid</span>
plotGrid(G), view(3), axis <span class="string">tight</span>
outInd = [G.faces.num-G.cells.num-sideLength+1; G.faces.num-G.cells.num-sideLength^2+sideLength];

<span class="comment">% here we plot the faces of a zero dirchlet boundary condition in pressure</span>
plotFaces(G, outInd, <span class="string">'r'</span>);
</pre><img vspace="5" hspace="5" src="injector_producer_array_01.png" alt=""> <h2>Define the rock<a name="4"></a></h2><p>porosity and permeability are the minimum number of parameters for rock</p><pre class="codeinput">rock.perm = 1*darcy*ones(G.cells.num, 1);
rock.poro = 0.5*ones(G.cells.num, 1);
</pre><h2>Define the fluid<a name="5"></a></h2><pre class="codeinput">pRef = 0*barsa;
fluid = initSimpleADIFluid(<span class="string">'phases'</span>, <span class="string">'W'</span>, <span class="string">'mu'</span>, 1*centi*poise, <span class="string">'rho'</span>, <span class="keyword">...</span>
                           1000*kilogram/meter^3, <span class="string">'c'</span>, 1e-10, <span class="string">'cR'</span>, 4e-10, <span class="keyword">...</span>
                           <span class="string">'pRef'</span>, pRef);
</pre><h2>Define the chemistry<a name="6"></a></h2><p>here we look at a simple tracer chemical system</p><pre class="codeinput">elements = {<span class="string">'O'</span>, <span class="string">'H'</span>, <span class="string">'Na*'</span>,<span class="string">'Cl*'</span>};

species = {<span class="string">'H+*'</span>, <span class="string">'OH-'</span>, <span class="string">'Na+'</span>, <span class="string">'H2O*'</span>, <span class="string">'NaCl'</span>,<span class="string">'Cl-'</span>};

reactions ={<span class="string">'H2O  = H+  + OH- '</span>,      10^-14*mol/litre, <span class="keyword">...</span>
            <span class="string">'NaCl = Na+ + Cl-'</span>,       10^1*mol/litre};


<span class="comment">% instantiate chemical model</span>
chemModel = ChemicalModel(elements, species, reactions);
</pre><h2>solve the chemistry for the initial and injected compositions<a name="7"></a></h2><p>we will be injected a low slainity fluid into a high salinity aquifer. we solve the system so that we can give the total element concentrations within the domain at the initial time, and define the boundary conditions</p><pre class="codeinput"><span class="comment">% initial chemistry</span>
Nai = 1e-1;
Cli = Nai;
Hi = 1e-7;
H2Oi = 1;
initial = [Nai Cli Hi H2Oi]*mol/litre;

<span class="comment">% we must repeat the initial chemistry for each cell of the system. This</span>
<span class="comment">% can be done by passing a vector to initState, or repmatting the state</span>
<span class="comment">% variable produced</span>
[initChemState, initreport]= chemModel.initState(repmat(initial, nc,1), <span class="string">'charge'</span>, <span class="string">'Cl'</span>);

<span class="comment">% the initial state must also contain a pressure field</span>
initChemState.pressure          = pRef*ones(nc,1);

<span class="comment">% injected chemistry</span>
Naf = 1e-3;
Clf = Naf;
Hf = 1e-10;
H2Of = 1;
injected = [Naf Clf Hf H2Of]*mol/litre;
[injChemState, injreport]= chemModel.initState(injected, <span class="string">'charge'</span>, <span class="string">'Cl'</span>);
</pre><pre class="codeoutput">Computing initial guess...
Solving chemical system...
Solving the chemical system with strict charge balance...
System is charge balanced to tolerance of 5.000000%...
Computing initial guess...
Solving chemical system...
Solving the chemical system with strict charge balance...
</pre><h2>Define the transport model<a name="8"></a></h2><pre class="codeinput">model = ChemicalTransportModel(G, rock, fluid, chemModel);
</pre><h2>Define the boundary conditions<a name="9"></a></h2><p>here we have two source cells in the southwest and northeast corners. there are two dirchlet conditions in the northwest and southeast corners allowing for outflow. Defining only neumann boundary conditions will underconstain the pressure solution such that a constant of integration is unknown.</p><pre class="codeinput"><span class="comment">% grab the volume of each cell in the domain</span>
pv = poreVolume(G,rock);

<span class="comment">% inject one pore volume into the cells per day.</span>
src                	= [];
src               	= addSource(src, [1; nc], pv(1:2)/day, <span class="string">'sat'</span>, 1);

<span class="comment">% define chemistry of the injected fluid</span>
src.elements        = injChemState.elements(end,:);
src.logElements     = injChemState.logElements(end,:);

<span class="comment">% specifiy dirchlet conditions for the composition</span>
bc                  = [];
outInd = [G.faces.num-G.cells.num-sideLength+1; G.faces.num-G.cells.num-sideLength^2+sideLength];
bc                  = addBC(bc, outInd, <span class="string">'pressure'</span>, [0; 0]*barsa, <span class="string">'sat'</span>, 1);
bc.elements         = initChemState.elements(end,:);        <span class="comment">% will not used if outflow</span>
bc.logElements      = initChemState.logElements(end,:);  <span class="comment">% will not used if outflow</span>
</pre><h2>Define the time stepping schedule<a name="10"></a></h2><p>here we define the time stepping schedule. it is recommended to ramp up the size of the time steps gradually</p><pre class="codeinput">schedule.step.val = [0.01*day*ones(5, 1); 0.1*day*ones(5,1); 1*day*ones(5, 1); 5*day*ones(10, 1)];
schedule.step.control = ones(numel(schedule.step.val), 1);
schedule.control = struct(<span class="string">'bc'</span>, bc, <span class="string">'src'</span>, src, <span class="string">'W'</span>, []);
</pre><h2>Run the simulation<a name="11"></a></h2><pre class="codeinput">[~, states, scheduleReport] = simulateScheduleAD(initChemState, model, schedule);
</pre><pre class="codeoutput">Solving timestep 01/25:                                   -&gt; 864 Seconds
Solving timestep 02/25: 864 Seconds                       -&gt; 1728 Seconds
Solving timestep 03/25: 1728 Seconds                      -&gt; 2592 Seconds
Solving timestep 04/25: 2592 Seconds                      -&gt; 3456 Seconds
Solving timestep 05/25: 3456 Seconds                      -&gt; 1 Hour, 720 Seconds
Solving timestep 06/25: 1 Hour, 720 Seconds               -&gt; 3 Hours, 2160 Seconds
Solving timestep 07/25: 3 Hours, 2160 Seconds             -&gt; 6 Hours
Solving timestep 08/25: 6 Hours                           -&gt; 8 Hours, 1440 Seconds
Solving timestep 09/25: 8 Hours, 1440 Seconds             -&gt; 10 Hours, 2880 Seconds
Solving timestep 10/25: 10 Hours, 2880 Seconds            -&gt; 13 Hours, 720 Seconds
Solving timestep 11/25: 13 Hours, 720 Seconds             -&gt; 1 Day, 13 Hours, 720.00 Seconds
Solving timestep 12/25: 1 Day, 13 Hours, 720.00 Seconds   -&gt; 2 Days, 13 Hours, 720.00 Seconds
Solving timestep 13/25: 2 Days, 13 Hours, 720.00 Seconds  -&gt; 3 Days, 13 Hours, 720.00 Seconds
Solving timestep 14/25: 3 Days, 13 Hours, 720.00 Seconds  -&gt; 4 Days, 13 Hours, 720.00 Seconds
Solving timestep 15/25: 4 Days, 13 Hours, 720.00 Seconds  -&gt; 5 Days, 13 Hours, 720.00 Seconds
Solving timestep 16/25: 5 Days, 13 Hours, 720.00 Seconds  -&gt; 10 Days, 13 Hours, 720.00 Seconds
Solving timestep 17/25: 10 Days, 13 Hours, 720.00 Seconds -&gt; 15 Days, 13 Hours, 720.00 Seconds
Solving timestep 18/25: 15 Days, 13 Hours, 720.00 Seconds -&gt; 20 Days, 13 Hours, 720.00 Seconds
Solving timestep 19/25: 20 Days, 13 Hours, 720.00 Seconds -&gt; 25 Days, 13 Hours, 720.00 Seconds
Solving timestep 20/25: 25 Days, 13 Hours, 720.00 Seconds -&gt; 30 Days, 13 Hours, 720.00 Seconds
Solving timestep 21/25: 30 Days, 13 Hours, 720.00 Seconds -&gt; 35 Days, 13 Hours, 720.00 Seconds
Solving timestep 22/25: 35 Days, 13 Hours, 720.00 Seconds -&gt; 40 Days, 13 Hours, 720.00 Seconds
Solving timestep 23/25: 40 Days, 13 Hours, 720.00 Seconds -&gt; 45 Days, 13 Hours, 720.00 Seconds
Solving timestep 24/25: 45 Days, 13 Hours, 720.00 Seconds -&gt; 50 Days, 13 Hours, 720.00 Seconds
Solving timestep 25/25: 50 Days, 13 Hours, 720.00 Seconds -&gt; 55 Days, 13 Hours, 720.00 Seconds
*** Simulation complete. Solved 25 control steps in 15 Seconds, 442 Milliseconds ***
</pre><h2>visualize the simulation<a name="12"></a></h2><pre class="codeinput">plotToolbar(G, states, <span class="string">'field'</span>, <span class="string">'pressure'</span>,<span class="string">'startplayback'</span>, true)
</pre><img vspace="5" hspace="5" src="injector_producer_array_02.png" alt=""> <h2>Copyright notice<a name="13"></a></h2><p>
<p><font size="-1">
Copyright 2009-2017 SINTEF ICT, Applied Mathematics.
</font></p>
<p><font size="-1">
This file is part of The MATLAB Reservoir Simulation Toolbox (MRST).
</font></p>
<p><font size="-1">
MRST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
</font></p>
<p><font size="-1">
MRST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
</font></p>
<p><font size="-1">
You should have received a copy of the GNU General Public License
along with MRST.  If not, see
<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses</a>.
</font></p>
</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2013b</a><br></p></div><!--
##### SOURCE BEGIN #####
close all;
clear;

%% add the necessary modeules 
mrstModule add ad-core ad-props ad-blackoil geochemistry mrst-gui
mrstVerbose off

%% Define the domain 
% here we look at a cartesian grid  with 100 cells
sideLength = 10;
G = cartGrid([sideLength, sideLength, 1], [sideLength, sideLength, 1]);
G = computeGeometry(G);
nc = G.cells.num;

% you can view the domain using plotGrid
plotGrid(G), view(3), axis tight
outInd = [G.faces.num-G.cells.num-sideLength+1; G.faces.num-G.cells.num-sideLength^2+sideLength];

% here we plot the faces of a zero dirchlet boundary condition in pressure
plotFaces(G, outInd, 'r');

%% Define the rock
% porosity and permeability are the minimum number of parameters for rock

rock.perm = 1*darcy*ones(G.cells.num, 1);
rock.poro = 0.5*ones(G.cells.num, 1);

%% Define the fluid
pRef = 0*barsa;
fluid = initSimpleADIFluid('phases', 'W', 'mu', 1*centi*poise, 'rho', ...
                           1000*kilogram/meter^3, 'c', 1e-10, 'cR', 4e-10, ...
                           'pRef', pRef);

%% Define the chemistry
% here we look at a simple tracer chemical system 

elements = {'O', 'H', 'Na*','Cl*'};

species = {'H+*', 'OH-', 'Na+', 'H2O*', 'NaCl','Cl-'};

reactions ={'H2O  = H+  + OH- ',      10^-14*mol/litre, ... 
            'NaCl = Na+ + Cl-',       10^1*mol/litre};


% instantiate chemical model
chemModel = ChemicalModel(elements, species, reactions);

%% solve the chemistry for the initial and injected compositions
% we will be injected a low slainity fluid into a high salinity aquifer. we
% solve the system so that we can give the total element concentrations
% within the domain at the initial time, and define the boundary conditions

% initial chemistry
Nai = 1e-1;
Cli = Nai;
Hi = 1e-7;
H2Oi = 1;
initial = [Nai Cli Hi H2Oi]*mol/litre;

% we must repeat the initial chemistry for each cell of the system. This
% can be done by passing a vector to initState, or repmatting the state
% variable produced
[initChemState, initreport]= chemModel.initState(repmat(initial, nc,1), 'charge', 'Cl');

% the initial state must also contain a pressure field 
initChemState.pressure          = pRef*ones(nc,1);

% injected chemistry
Naf = 1e-3;
Clf = Naf;
Hf = 1e-10;
H2Of = 1;
injected = [Naf Clf Hf H2Of]*mol/litre;
[injChemState, injreport]= chemModel.initState(injected, 'charge', 'Cl');

%% Define the transport model
model = ChemicalTransportModel(G, rock, fluid, chemModel);

%% Define the boundary conditions
% here we have two source cells in the southwest and northeast corners.
% there are two dirchlet conditions in the northwest and southeast corners
% allowing for outflow. Defining only neumann boundary conditions will
% underconstain the pressure solution such that a constant of integration
% is unknown.

% grab the volume of each cell in the domain
pv = poreVolume(G,rock);

% inject one pore volume into the cells per day.
src                	= [];
src               	= addSource(src, [1; nc], pv(1:2)/day, 'sat', 1);

% define chemistry of the injected fluid
src.elements        = injChemState.elements(end,:);
src.logElements     = injChemState.logElements(end,:);

% specifiy dirchlet conditions for the composition
bc                  = [];
outInd = [G.faces.num-G.cells.num-sideLength+1; G.faces.num-G.cells.num-sideLength^2+sideLength];
bc                  = addBC(bc, outInd, 'pressure', [0; 0]*barsa, 'sat', 1);
bc.elements         = initChemState.elements(end,:);        % will not used if outflow
bc.logElements      = initChemState.logElements(end,:);  % will not used if outflow


%% Define the time stepping schedule
% here we define the time stepping schedule. it is recommended to ramp up
% the size of the time steps gradually

schedule.step.val = [0.01*day*ones(5, 1); 0.1*day*ones(5,1); 1*day*ones(5, 1); 5*day*ones(10, 1)];
schedule.step.control = ones(numel(schedule.step.val), 1);
schedule.control = struct('bc', bc, 'src', src, 'W', []);


%% Run the simulation

[~, states, scheduleReport] = simulateScheduleAD(initChemState, model, schedule);

%% visualize the simulation
plotToolbar(G, states, 'field', 'pressure','startplayback', true)

%% Copyright notice
%
% <html>
% <p><font size="-1">
% Copyright 2009-2017 SINTEF ICT, Applied Mathematics.
% </font></p>
% <p><font size="-1">
% This file is part of The MATLAB Reservoir Simulation Toolbox (MRST).
% </font></p>
% <p><font size="-1">
% MRST is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% </font></p>
% <p><font size="-1">
% MRST is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% </font></p>
% <p><font size="-1">
% You should have received a copy of the GNU General Public License
% along with MRST.  If not, see
% <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses</a>.
% </font></p>
% </html>


##### SOURCE END #####
--></body></html>