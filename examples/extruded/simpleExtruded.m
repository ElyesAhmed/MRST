%{
Single phase 3D example with the matrix and fracture grid generated by
extruding their corresponding 2D grids. The flow problem is solved both by
a fine-scale and a multiscale solver.

Notice that you need to have Metis installed to get this example to work.
To get Metis working, you also need to set the global variable METISPATH.
This can be done in your 'startup_user.m' file.
%}

% Load necessary modules, etc 
mrstModule add hfm;             % hybrid fracture module
mrstModule add coarsegrid;      % functionality for coarse grids
mrstModule add ad-core;         % NNC support for coarse grids
mrstModule add new-multiscale;  % MsRSB solvers
mrstModule add mrst-gui;        % plotting routines
checkLineSegmentIntersect;      % ensure lineSegmentIntersect.m is on path

%% Grid and fracture lines

celldim = [50 50];
G = cartGrid(celldim);
G = computeGeometry(G);
fl = [5 5 45 45; 5 45 45 5];
layers = 50;
flayers = 11:40;

%% Process fracture lines

dispif(mrstVerbose, 'Processing user input...\n\n');
a = 1/25;
[G,fracture] = processFracture2D(G,fl); fracture.aperture = a;
figure;
plotFractureLines(G,fracture,'lines');
axis tight; box on

%% Compute CI and construct fracture grid

dispif(mrstVerbose, 'Computing CI and constructing fracture grid...\n\n');
G = CIcalculator2D(G,fracture);
min_size = 0.5; cell_size = 0.5; % minimum and average cell size.
[G,F,fracture] = gridFracture2D(G,fracture,'min_size',min_size,'cell_size',cell_size);
clf; plotFractureNodes2D(G,F,fracture); box on

%% Make layered grid

Gl = makeLayers(G,layers,flayers);

%% Set rock properties in fracture and matrix

p = gaussianField(Gl.cartDims, [0.2 0.4], [9 5 5], 3.5);
K = p.^3.*(1e-5)^2./(0.81*72*(1-p).^2);

Gl.rock = makeRock(Gl, K(:), p(:));
K_frac = 10000; % Scaling factor = K_frac/K_mat D
poro_frac = 0.5;
Gl = makeRockFrac(Gl, K_frac, 'permtype','homogeneous','porosity',poro_frac);

clf; plotToolbar(Gl,Gl.rock);
colormap(jet); view (-135,30);
axis tight equal off

%% Define fluid properties

fluid = initSingleFluid('mu' , 1*centi*poise, ...
    'rho', 1*kilogram/meter^3);

%% Global grid with NNC's and corresponding transmissibility

[Gl,T] = makeNNCextruded(G,Gl,F,fracture,flayers);
G = Gl; clear Gl

%% Initialize state variables

dispif(mrstVerbose, 'Computing coefficient matrix...\n\n');
state  = initResSol (G, 0);
state.wellSol = initWellSol(G, 0);
[A,q] = getSystemIncompTPFA(state, G, T, fluid, 'use_trans', true);

%% Add Wells

[nx, ny, nz] = deal(G.cartDims(1), G.cartDims(2), G.cartDims(3));
cellinj = nx*ny*(nz-1)+1:nx:nx*ny*nz;
cellprod = nx:nx:nx*ny;

W = [];
W   = addWell(W, G.Matrix, G.Matrix.rock, cellinj, 'Type', 'rate',...
    'Val', 1000/day, 'Sign',1, 'Comp_i', [1, 0], 'Name', 'Injector');
W   = addWell(W, G.Matrix, G.Matrix.rock, cellprod, ...
    'Type', 'bhp', 'Val', 50*barsa(), 'Sign', -1, 'Comp_i', [0, 1], 'Name', 'Producer');

%% Setup multiscale grids

G.type{1,1} = 'layered';

% Partition matrix

coarseDims = [10 10 10];
pm = partitionMatrix(G, 'coarseDims', coarseDims, 'use_metis', false);
CGm = getRsbGridsMatrix(G, pm, 'fullyCoupled', false, 'Wells', W);

% Partition fracture

nw = fracture.network;
coarseDimsF = [3 3];
p  = partitionFracture(G, pm, nw, 'partition_frac'   , true   , ...
    'use_metisF'       , false  , ...
    'coarseDimsF'      , coarseDimsF );

p = processPartition(G,compressPartition(p));
pf = p(G.Matrix.cells.num+1:end)-max(p(1:G.Matrix.cells.num));

% Coarse Grids

CG = generateCoarseGrid(G, p);
% Add centroids / geometry information on coarse grid
CG = coarsenGeometry(CG);
Gf = assembleFracGrid(G);
CGf = generateCoarseGrid(Gf, pf);
CGf = coarsenGeometry(CGf);

% Support Regions

[CG,CGf] = storeFractureInteractionRegion(CG, CGf, CGm, ...
    'excludeBoundary' , false , ...
    'removeCenters'   , false , ...
    'fullyCoupled'    , false );

%% Plot coarsegrid

clf; % plotToolbar(G.Matrix,G.Matrix.rock);
colormap(jet); view(-135,30)
axis tight equal off
plotGrid(CG, 'facealpha', 0, 'linewidth', 2);
plotWell(G,W);

%% Incompressible 1-phase FS

dispif(mrstVerbose, '\nSolving fine-scale system...\n\n');
state_fs = incompTPFA(state, G, T, fluid,  ...
    'Wells', W, 'MatrixOutput', true, 'use_trans',true);

%% Compute basis functions

dispif(mrstVerbose, 'Computing basis functions...\n\n');
basis_sb = getMultiscaleBasis(CG, A, 'type', 'rsb');
clf; plotToolbar(G,basis_sb.B); view(-135,30)
axis tight; c = colormap(jet);
colormap(c); colorbar;
title('Basis Functions in the matrix');

%% Compute multiscale solution

state_ms = incompMultiscale(state, CG, T, fluid, basis_sb, 'Wells', W, ...
    'use_trans',true);

%% Solve using MS-ILU and MS-GMRES

fn = getSmootherFunction('type', 'ilu');

[~,report] = incompMultiscale(state, CG, T, fluid, basis_sb,...
    'Wells', W, 'use_trans', true, 'tolerance', 1e-8, 'iterations', 100,...
    'useGMRES', false, 'reconstruct', true, 'getSmoother', fn);

[~,report2] = incompMultiscale(state, CG, T, fluid, basis_sb,...
    'Wells', W, 'use_trans', true, 'tolerance', 1e-8, 'iterations', 100,...
    'useGMRES', true, 'reconstruct', true, 'getSmoother', fn);

%% Plot results

figure;
plotToolbar(G, state_fs.pressure)
colormap jet; colorbar
view(-135,30)
axis tight off
title('Fine scale')

figure;
plotToolbar(G, state_ms.pressure)
colormap jet; colorbar
view(-135,30)
axis tight off
title('F-MsRSB')

L1 = abs(state_ms.pressure-state_fs.pressure)./state_fs.pressure;
figure;
plotToolbar(G, L1)
colormap jet; colorbar
view(-135,30)
axis tight off
L1_eq = '$$ \frac{| P_i^{fs}-P_i^{f-msrsb} | }{ P_i^{fs}} $$';
title(L1_eq,'interpreter','latex');

%% Plot convergence

figure;
semilogy(report.resvec, ':+'); hold on;
semilogy(report2.resvec, 's-');
legend('Convergence of ILU(0)', 'Convergence of GMRES');
title('Iterative convergence');