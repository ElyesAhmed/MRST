% A short tutorial to show elastisity solution on homogenous over burden
% more examples can be generated by squareTest.m, see also
% square_2d_example which uses this tests
%% Define parameters
if(false)
opt=struct('L',[1 1],...
    'cartDims',[6 6],...
    'grid_type','square',...
    'disturb',0.02,... %parameter for disturbing grid
    'E',4e7,...  %youngs modolo
    'nu',0.44);% poiso ratio
else
  opt=struct('L',[1 1],...
    'cartDims',[4 3],...
    'grid_type','square',...
    'disturb',0.0,... %parameter for disturbing grid
    'E',1e7,...  %youngs modolo
    'nu',0.2);% poiso ratio  
end
% define Grid
G1=squareGrid(opt.cartDims-1,opt.L,'grid_type','pebi','disturb',0.05);
%G1=cartGrid(opt.cartDims-1,opt.L);
%G2=squareGrid(opt.cartDims,opt.L,'grid_type','pebi','disturb',0.04);
%G2=squareGrid(opt.cartDims,opt.L,'grid_type','triangle','disturb',0.0);
G2=cartGrid(opt.cartDims,opt.L);
G2=cartGrid(opt.cartDims+1,opt.L);
%G3=cartGrid(opt.cartDims+2,[opt.L(1)+0.3,opt.L(2)]);
G3=squareGrid(opt.cartDims+2,[opt.L(1)+0.3,opt.L(2)],'grid_type','pebi','disturb',0.05)
G4=cartGrid(opt.cartDims+[7,1],[3*opt.L(1),opt.L(2)]);
dx=0.05;
G5=cartGrid([opt.cartDims(1)*30,1],[3*opt.L(1),dx]);
G6=cartGrid([3,10],[opt.L(1),3*opt.L(2)+dx]);
G=G1;
G = glue2DGrid(G1, translateGrid(G2, [opt.L(1), -0.0]));
%G = glue2DGrid(G2, translateGrid(G1, [opt.L(1), -0.0]));
G = glue2DGrid(G, translateGrid(G3, [0, -opt.L(2)]));
%G = glue2DGrid(G2, translateGrid(G1, [opt.L(1), -0.0]));
if(false)
G = glue2DGrid(G, translateGrid(G3, 2*[opt.L(1), 0.0]));
G = glue2DGrid(G, translateGrid(G5, [0, opt.L(2)]));
G = glue2DGrid(G, translateGrid(G4, [0, opt.L(2)+dx]));
G = glue2DGrid(G, translateGrid(G4, [0, -opt.L(2)]));
G = glue2DGrid(G, translateGrid(G6, [- opt.L(1), -opt.L(2)]));
G = glue2DGrid(G, translateGrid(G6, [3*opt.L(1), -opt.L(2)]));
G.cells=rmfield(G.cells,'indexMap')
G=removeCells(G,400:455);
G=removeCells(G,310:312);
end
G=computeGeometry(G);
Lx=max(G.nodes.coords(:,1));
Ly=max(G.nodes.coords(:,2));
G.nodes.coords(:,1)=G.nodes.coords(:,1)*opt.L(1)./Lx;
G.nodes.coords(:,2)=G.nodes.coords(:,2)*opt.L(2)./Ly;
%G = glue2DGrid(G, translateGrid(G4, [0, -opt.L(2)]));
%G = glue2DGrid(G, translateGrid(G3, [2*opt.L(1), 0.0]));
%G=sortEdges(G);
%G=cartGrid(opt.cartDims,[3*opt.L(1),opt.L(1)]);
%{
G_old=G;
[coords,ii,jj]=unique(G_old.nodes.coords,'rows');
G=G_old;
G.nodes.coords=coords;
G.nodes.num=numel(ii);
G.faces.nodes=jj(G.faces.nodes);
%}
%Lx=max(G.nodes.coords(:,1));
%Ly=max(G.nodes.coords(:,2));
%G=G1;
%G.nodes.coords=G.nodes.coords(
%{
oldcoords=G.nodes.coords;
G.nodes.coords(:,1)=-oldcoords(:,2)+opt.L(2);
G.nodes.coords(:,2)=oldcoords(:,1);
%}
Lx=max(G.nodes.coords(:,1));
Ly=max(G.nodes.coords(:,2));

%G = glue2DGrid(G, G4);%translateGrid(G4, [0, 0.0*opt.L(2)]));
if(opt.disturb>0)
    G=twister(G,opt.disturb);
end
Lx=max(G.nodes.coords(:,1));
Ly=max(G.nodes.coords(:,2));
clf,plotGrid(G);%,plotGrid(G4,'FaceColor','r')
%%
G=sortEdges(G);
%%
% gennerate extra mappings needed
G=mrstGridWithFullMappings(G);
% generate weights needed
G=computeGeometryCalc(G);
figure()
clf,plotGrid(G)
%%
G3d=makeLayeredGrid(G,3)
clf,plotGrid(G3d)
%
%% Find sides of domain
% find sides
oside={'Left','Right','Back','Front'};
bc=cell(4,1);
if(false)
for i=1:numel(oside);
    bc{i}=pside([],G,oside{i},0);
    bc{i}= rmfield(bc{i},'type');
    bc{i}= rmfield(bc{i},'sat');
end
else
    assert(G.griddim==2);
    x=[0,Lx];
    for i=1:2
        clear find
        faces=find(abs(G.faces.centroids(:,1)-x(i))<eps);
        bc{i}=addBC([], faces, 'pressure', 0);
        bc{i}= rmfield(bc{i},'type');
        bc{i}= rmfield(bc{i},'sat');
    end
    y=[0,Ly];
    for i=1:2
        faces=find(abs(G.faces.centroids(:,2)-y(i))<eps);
        bc{i+2}=addBC([], faces, 'pressure', 0);
        bc{i+2}= rmfield(bc{i+2},'type');
        bc{i+2}= rmfield(bc{i+2},'sat');
    end
end
% finde node of the differens sides and prepare elastisity boundary
% conditions
for i=1:4
    inodes=mcolon(G.faces.nodePos(bc{i}.face),G.faces.nodePos(bc{i}.face+1)-1);
    nodes=unique(G.faces.nodes(inodes));
    disp_bc=struct('nodes',nodes,...
                    'uu',0,...
                    'faces',bc{i}.face,...
                    'uu_face',0,...
                    'mask',true(numel(nodes),G.griddim));
    bc{i}.el_bc=struct('disp_bc', disp_bc,'force_bc',[]);
end
%% define load as gravity
density=3000*0;% kg/m^3
grav=0;% gravity 
load=@(x) -(grav*density)*repmat([0,1],size(x,1),1);
% set boundary dispace ment function to zeros
bcdisp=@(x) x*0.0;


% set up boundary conditions for each side
clear bc_el_sides
% set direclet boundary conditions at selected sides
    % on left side nod displace ment in x direction only, this is done by
    % mask
    bc_el_sides{1}=bc{1}; 
    %bc_el_sides{1}.el_bc.disp_bc.mask(:,2)=false;
    % same as x direction
    bc_el_sides{2}=bc{2};
    %bc_el_sides{2}.el_bc.disp_bc.mask(:,2)=false;
    %bc_el_sides{2}=[];
    % no displace ment in y direction at the bottum
    bc_el_sides{3}=bc{3};
    bc_el_sides{3}.el_bc.disp_bc.mask(:,1)=false;
    bc_el_sides{3}=[];
    bc_el_sides{4}=[];
    % remove    
    
% collect bounary conditions
nodes=[];
faces=[];
mask=[];
for i=1:numel(bc)
    if(~isempty(bc_el_sides{i}))
        nodes=[nodes;bc_el_sides{i}.el_bc.disp_bc.nodes];%#ok
        faces=[faces;bc_el_sides{i}.el_bc.disp_bc.faces];%#ok
        mask=[mask;bc_el_sides{i}.el_bc.disp_bc.mask];%#ok
    end
end
disp_node=bcdisp(G.nodes.coords(nodes,:));
disp_faces=bcdisp(G.faces.centroids(faces,:));
disp_bc=struct('nodes',nodes,'uu',disp_node,'faces',faces,'uu_face',disp_faces,'mask',mask); 
% define forces at boundary     
%find midpoint face set all force corresponding to the "weight fo the ting
%at limited area
sigma=opt.L(2)/10;force=0*barsa;
%face_force =@(x) force*exp(-(((x(:,1)-opt.L(1)/2))./sigma).^2)+100*barsa;
face_force =@(x) force*sign(x(:,1)-opt.L(1)/2)+100*barsa;
faces=bc{4}.face;
% make force boundary structure NB force is in units Pa/m^3
force_bc=struct('faces',faces,'force',bsxfun(@times,face_force(G.faces.centroids(faces,:)),[0 -1]));
    
% final structure fo boundary conditions
el_bc=struct('disp_bc',disp_bc,'force_bc',force_bc);


% define rock parameters
Ev=repmat(opt.E,G.cells.num,1);nuv=repmat(opt.nu*0+0.4,G.cells.num,1);
C=Enu2C(Ev,nuv,G)
% solve system also with profiler on
profile off;profile on
lsolve=@mldivide;
%[uu,SVEM,A]=VEM_linElast(G,Ev,nuv,el_bc,load,'type','mrst2','linsolve',lsolve,'local_assambly',false);
uu=VEM_linElast(G,C,el_bc,load,'type','mrst2','linsolve',lsolve,'local_assambly',false);
profile off; profile viewer
% Plot displacement in x direction
plotopts={'EdgeAlpha',0.0,'EdgeColor','none'};
plotopts1={'EdgeAlpha',0.01};
clf,plotNodeData(G,uu(:,2),plotopts{:}),colorbar(),

% Plot displacement in x direction
clf,plotNodeData(G,uu(:,1),plotopts{:}),colorbar(),
% Plot distorted grid with factor 10
% remember we have a linear system
fac=1;
clf,plotGridDeformed(G,uu*fac)
%%
return
%% calulate divergence and plot
vdiv=VEM_div(G);
mdiv=vdiv*reshape(uu',[],1)./G.cells.volumes;
clf,plotCellDataDeformed(G,mdiv,uu*fac,plotopts1{:}),colorbar()
%clf,plotCellDataDeformed(G,uu(:,1),uu*fac,plotopts1{:}),colorbar()

%% calulate stress and strain
C=Enu2C(Ev,nuv,G);
[S,extra]=VEM_assemble(G,C,'add_operators',true);
op=extra.op;
stress=-reshape(op.D*op.WC'*op.assamb'*reshape(uu',[],1),3,[])';
strain=reshape(op.WC'*op.assamb'*reshape(uu',[],1),3,[])';

%% calulate eigen values and eigen vectors 
[sigm,evec]=calStressEigs(G,stress);
mc=(sigm(:,2)-sigm(:,1))./(sigm(:,2)+sigm(:,1));
% plot angle of factor if Moore Colume curve crosses origo
clf,plotCellData(G,real(asin(mc)/pi*180),plotopts{:});colorbar,caxis([0 60])
%clf,plotCellData(G,mc,plotopts{:});colorbar,caxis([0 90])
%% plot radi of 
clf,plotCellData(G,sigm(:,2)-sigm(:,1),plotopts{:});colorbar

%% do compearson with un pressured case
el_bc0=struct('disp_bc',disp_bc,'force_bc',[]);
uu0=VEM_linElast(G,Ev,nuv,el_bc0,load,'type','mrst2','linsolve',lsolve,'local_assambly',false);
du=uu-uu0;
clf,plotNodeData(G,du(:,1),plotopts{:}),colorbar
