function polygons = computeGridSlicePolygons(G, coord, varargin)
% Compute polygons generated by intersection of grid and plane(s). The two 
% modes are:
% 1) Single coord: optional argument 'normal' is used to determine plane. 
%    Intersection can furter be restricted by optional input parameters 
%    'radius' and 'axis'
% 2) Multiple coord: optional argument 'cutDir' is used to determine plane. 
%    Slices grid along segment(s) defined be coord. Slice width can be 
%    controlled by optional argumet 'radius'
% vertical s
%
% SYNOPSIS:
%   poly = computeVerticalGridIntersection(G, segments)
%
% DESCRIPTION:
%
%
% REQUIRED PARAMETERS:
%
%   G        - Grid structure with geometry and preferably 'bbox'-field included
%              for G.faces (see addBoundingBoxFields)
%
%   coords   - Nx3 matrix. Any N>0 number of coords.   
%              If N ==1, a single cut-plane is defined by point and optional 
%              parameter 'normal'.
%              If N >= 2, N-1 connected planar slices are produced where slice k
%              is the set of coords given by 
%                  s*coords(k,:) + (1-s)*coords(k+1,:) + t*cutDir
%              with 0<=s<=1. Slicing direction must be given by optional
%              parameter 'cutDir'.
% OPTIONAL PARAMETERS:
%  'faceIx'  : Consider only subset of faces. 
%              Default: 1:G.faces.num
%  'cellIx'  : Consider only subset of faces as given by subset of cells.
%              Default: 1:G.cells.num
%  'cutDir'  : 3x1 vector (or 'x','y','z') giving "slicing" direction. 
%              If N==1, this input is ignored. For canonical directions, a 
%              slight performance gain is obtained by e.g., setting 
%              cutDir = 'x' rather than cutDir = [1 0 0]'
%              Default: 'z' (or determined from cut-plane)
%  'normal'  : 3x1 vector (or 'x','y','z') giving normal direction to 
%              cut-plane. If N>=2, this input is ignored. For canonical 
%              directions, a slight performance gain is obtained by e.g., 
%              setting cutDir = 'x' rather than cutDir = [1 0 0]'
%              Default: 'x' (or determined from coords and cutDir)
%  'radius'  : If N == 1:
%                 1xd vector d = 1 or 3. Restricts slice(s) to ellipse. In
%                 particular:
%                 d == 1: restrict to ball with given radius
%                 d == 3: restrict to ellipsoid with given radii
%              If N >= 1: 
%                 scalar giving half width of slice
%              Default: empty (no restriction)
% 'axis'     : 3x3 matrix where each column give principal axis of 
%              ellipsoid 
%              Deafault: eye(3)
% 
% EXAMPLE:
%%
% G  = addBoundingBoxFields(computeGeometry(cartGrid([20 20 10])));
% poly = computeGridSlicePolygons(G, [15*sin((0:.1:2))', .5*cos(0:.1:2)', (0:.1:2)'], 'cutDir', [0 0 1]);
% patch('Faces', poly.nodes, 'Vertices', poly.coords3D, 'FaceColor', 'y')
% view(3)
%%
%{
Copyright 2009-2020 SINTEF Digital, Mathematics & Cybernetics.

This file is part of The MATLAB Reservoir Simulation Toolbox (MRST).

MRST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

MRST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with MRST.  If not, see <http://www.gnu.org/licenses/>.
%}
opt = struct('faceIx',                      [], ...
             'cellIx',                      [], ...
             'cutDir',                      [], ...
             'radius',                      [], ...
             'normal',                      [], ...
             'axis',                    eye(3), ...
             'removeRepeated',           false, ...
             'removeDegenerates',         true, ...
             'removeFullyClamped',        true, ...
             'removePartialCuts',        false, ...
             'outputForGridProcessing',  false, ...
             'tol',                       1e-6, ...
             'parallellTol',              1e-6);
opt = merge_options(opt, varargin{:});

[seg, cutDir, r, opt] = processInput(G, coord, opt);

[tol, parTol] = deal(opt.tol, opt.parallellTol);

% Add face bounding boxes if not present
if ~isfield(G.faces, 'bbox')
    G = addBoundingBoxFields(G);
end

% If multiple segments, pick initial subset of faces covering all
% segProj  = seg - (seg*cutDir)*cutDir';  ??
nseg = size(seg,1)-1;
if nseg > 1
    fix0 = getFacesCloseToSegment(G, seg, 'projVec', cutDir, 'faceIx', opt.faceIx);
else
    fix0 = [];
end
% prealocate for polygon vertices, coord along segment, 
[p, t, fno, clamp] = deal(cell(1, nseg));
if opt.outputForGridProcessing
   [sval, snap, nix] = deal(cell(1, nseg));
end

% doSnap = snapTol > 0;
%if doSnap
%    [six, sp] = deal(cell(1, nseg));
% end
ts     = 0;
np     = size(coord, 1);
cumlen = zeros(nseg+1, 1);

% Main loop ---------------------------------------------------------------

for k = 1:nseg
    curseg     = seg([k, k+1],:);
    fix = getFacesCloseToSegment(G, curseg, 'faceIx', fix0, 'projVec', cutDir);
    % skip second round of subset reduction, not fully robust
    %if ~isempty(r)
    %   fix = shapeSubset(G, fix, curseg, cutDir, r);
    %end
    
    % Collect all segments for current set of faces
    [p1, p2, faceNo, nodeIx] = getFaceSegments(G, fix, opt.outputForGridProcessing);
    
    v  = diff(curseg);
    vu = v(:)/norm(v(:));
    % cut-plane : n'x = d 
    n = null([vu';cutDir']);
    assert(size(n,2)==1, 'Invalid slicing direction')
    d = curseg(1,:)*n;
    
    % Compute segment - plane intersections
    [pcur, faceNoIx, sValue, snapIx, snapCoord] = getPlaneIntersections(p1, p2, n, d, tol, parTol);
        
    if np >= 2
        % For a given segment remove intersections that don't project to 0 < t < tmax 
        % except for first and last segments where points are clamped  
        [isFirst, isLast] = deal(k == 1, k == nseg);
        [pcur, tcur, isRemoved, isClamped] = clampSides(pcur, curseg, r, cutDir, n, isFirst, isLast, opt.removePartialCuts);
    else
        % clamping/removing is only performed if r's are finite
        [pcur, tcur, isRemoved, isClamped] = clampEllipsoid(pcur, curseg, r, cutDir, opt.removePartialCuts);
    end
    
    if any(isRemoved)
        faceNoIx = faceNoIx(~isRemoved);
        sValue   = sValue(~isRemoved);
        snapIx   = snapIx(~isRemoved);
        %if doSnap
        %    [snapIx, snapCoord] = deal(snapIx(~isRemoved), snapCoord(~isRemoved));
        %end
    end
    % keep track of parameter t along segments
    tcur        = ts + tcur;      % t's for current intersections
    ts          = ts + norm(v);   % final t for current segment
    cumlen(k+1) = ts;
    [p{k}, t{k}, fno{k}, clamp{k}] = deal(pcur, tcur, faceNo(faceNoIx), isClamped);
    % extra output
    if opt.outputForGridProcessing
        [sval{k}, snap{k}, nix{k}] = deal(sValue, snapIx, nodeIx(faceNoIx));
    end
end

% Collect and reshape -----------------------------------------------------
[p, t, fno, clamp] = deal(vertcat(p{:}), vertcat(t{:}), vertcat(fno{:}), vertcat(clamp{:}));
if opt.outputForGridProcessing
    [sval, snap, nix] = deal(vertcat(sval{:}), vertcat(snap{:}), vertcat(nix{:}));
end
% if doSnap
%     [six, sp] = deal(vertcat(six{:}), vertcat(sp{:}));
% end

% Reshape intersection info to all intersected grid cells
cno   = G.faces.neighbors(fno,:); 
isPos = cno > 0;
cno   = [cno(isPos(:,1),1); cno(isPos(:,2),2)];
pix   = [find(isPos(:,1)); find(isPos(:,2))];
[p, t, clamp] = deal(p(pix,:), t(pix), clamp(pix));
if opt.outputForGridProcessing
    [fno, nix, sval] = deal(fno(pix), nix(pix), sval(pix));
end

if isempty(cno)
    polygons = [];
    warning('Empty set of intersected cells')
    return;
end

% reindex to local cell-map
cix = unique(cno);
if cix(1) == 0
    cix = cix(2:end);
end
rix     = sparse(cix, 1, (1:numel(cix))', G.cells.num, 1);
cno_loc = full(rix(cno));
% compute current number of vertices for each polygon
nvert   = accumarray(cno_loc, ones(size(cno_loc)), [numel(cix), 1]);

% Orientation of vertices -------------------------------------------------

% project intersection points onto 2D (t, p_cut) -plane and orient polygon 
% vertices accoring to angle wrt poly center
p_cut = p*cutDir - seg(1,:)*cutDir;
pp    = [t, p_cut];
cent  = [accumarray(cno_loc, pp(:,1)), accumarray(cno_loc, pp(:,2))]./nvert;
rp    = pp - cent(cno_loc,:);
theta = atan2(rp(:,2), rp(:,1));
[info, order] = sortrows([cno_loc, theta]);

polyIx = ':';

% Polynom processing ------------------------------------------------------

% typically many repeated nodes, these are needed in subsequent
% grid-processing, otherwise can be removed
if opt.removeRepeated
    isSame  = [false; diff(info(:,1)) == 0 & abs(diff(info(:,2))) < sqrt(eps)];
    order   = order(~isSame);
end
cno_loc = cno_loc(order);
% recompute number of vertices 
nvert  = accumarray(cno_loc, ones(size(cno_loc)), [numel(cix), 1]);

% optionally remove clamped and/or degenerate cells 
if opt.removeDegenerates || opt.removeFullyClamped
    nfixed = 1;
    if opt.removeFullyClamped
        nfixed = accumarray(cno_loc, ~clamp(order), [numel(cix), 1]);
    end
    isDeg = false;
    if opt.removeDegenerates
        isDeg = nvert <= G.griddim -1;
    end
    polyIx = ~isDeg & nfixed >=1;
    orderIx = rldecode(polyIx, nvert);
    % reindex to subset
    nvert    = nvert(polyIx);
    order    = order(orderIx);
    cno_loc  = cno_loc(orderIx);
end

% Assemble output ---------------------------------------------------------

[p, p_cut, t] = deal(p(order,:), p_cut(order), t(order));
cno = cix(cno_loc);


% Construct polygonal info
maxp  = max(nvert); 
npol  = numel(nvert);
cumc  = cumsum(nvert);
pos   = [1; cumc(1:end-1)+1];
nodes = zeros(npol, maxp);
cl    = (1:numel(cno))';
for k = 1:maxp
   nodes(:,k) =  cl(min(pos+k-1, cumc));
end

polygons = struct('nodes',           nodes, ...
                  'coords3D',            p, ... 
                  'coords2D',   [t, p_cut], ...
                  'cellIx',    cix(polyIx), ...
                  'segments',          seg, ...
                  'cumlength',      cumlen);
if opt.outputForGridProcessing
    polygons.faceIx = fno(order);
    polygons.nodeIx = nix(order,:);
    %polygons.theta  = theta(order);
    polygons.tValue = sval(order);
    polygons.snapIx = [];%snap(order);
    polygons.normal = n;  % not needed
end
end

% -------------------------------------------------------------------------
% -------------------------------------------------------------------------
function [p1, p2, faceNo, nodeIx] = getFaceSegments(G, f, outputNodeIndex)
[np1, np2] = deal(G.faces.nodePos(f), G.faces.nodePos(f+1));
nNodes = np2-np1;
nSeg   = numel(nNodes);
faceNo = rldecode(f(:), nNodes);

nodes = G.faces.nodes(mcolon(np1, np2-1));
locpos = [1; cumsum(nNodes)+1];
next   = (2:numel(nodes)+1) .';
next(locpos(2 : end) - 1) = locpos(1 : end-1);

p1 = G.nodes.coords(nodes,:);
p2 = G.nodes.coords(nodes(next),:);
nodeIx = [];
if outputNodeIndex
    nix1 = mcolon(ones(nSeg, 1), nNodes)';
    nix2 = nix1(next);
    nodeIx = [nix1, nix2];
end
end
% -------------------------------------------------------------------------
function [p, ix, t, six, sp] = getPlaneIntersections(p1, p2, n, d, tol, parTol)
% compute intersection points of line-segments with plane
v  = p2-p1;
normv = sqrt(sum(v.^2,2));

vn = v*n;
%ok = abs(vn) > parTol*norm(max(v));
ok = abs(vn) > parTol*normv;
t  = nan(size(vn));
t(ok)  = -(p1(ok,:)*n-d)./vn(ok);
if ~all(ok) % check if in plane
    ii = abs((p1(~ok,:)*n-d)./d) < parTol;
    if any(ii)
        tii     =  nan(size(ii));
        tii(ii) = 0;
        t(~ok)  = tii;
    end
end
% Might want to consider a tollerance in next line but this will 
% potentially screw up later logic. However, if there is a finite 
% tol such that tol/(magnitude of coordinates) is sufficenlty 
% many orders og magnitude larger than eps, this should be OK 
ix = find(t>=0 & t <= 1);
t  = t(ix);
p  = p1(ix,:) + bsxfun(@times, t, v(ix,:));
sp = []; % not currently considered
if tol == 0
    [six, sp] = deal([]);
else
    six0    = t < tol;
    t(six0) = 0;
    p(six0) = p1((ix(six0))); % hard-set to prevent round-offs
    
    six1    = t > 1-tol;
    t(six1) = 1;
    p(six0) = p2((ix(six0))); % hard-set to prevent round-offs
    six = six0 | six1;
end

end

% -------------------------------------------------------------------------
function [segments, cutDir, radius, opt] = processInput(G, coord, opt)
[cutDir, radius, normal] = deal(opt.cutDir(:), opt.radius, opt.normal(:));
% check that cut-plane is sufficiently defined
np = size(coord, 1);
if np == 1
    if isempty(normal)
        error('Input of a single point requires additional input of cut-plane normal');
    elseif ~isempty(cutDir)
        warning('Redundant input: ''cutDir'' will be ignored');
        cutDir = [];
    end
else %(np > 1)
    if isempty(cutDir)
        error('Input of multiple coords requires additional input of  optional arguemt ''cutDir''');
    elseif ~isempty(normal)
        warning('Redundant input: ''normal'' will be ignored');
        normal = [];
    end
end
if np > 1
    segments = coord;
    if isempty(cutDir)
        cutDir   = [0 0 1]';
    end
else % cut-plane given point + normal
    normal = normal/norm(normal);
    if any(~isfinite(radius)), radius = []; end
    if numel(radius) <= 1
        if isempty(radius) % need to find sufficient radius to cover grid
            radius_tmp = norm(max(G.nodes.coords) - min(G.nodes.coords));
        else
            radius_tmp = radius;
        end
        % find some direction orthogoanl to normal
        tmp = null(normal');
        v   = tmp(:,1);
        segments = [coord - radius_tmp*v'; coord + radius_tmp*v'];
        cutDir   = tmp(:,2);
    else
        Q = opt.axis;
        if norm(Q'*Q-eye(3)) > sqrt(eps)
            warning('Supplyed axis does not appear to be orthogonal');
            Q = orth(Q);
        end        
        % find cut-plane ellipse
        [radius, Q] = getEllipse(normal, radius, Q);
        % select segment and cutDir based on radius/axis
        segments = [coord - radius(1)*Q(:,1)'; coord + radius(1)*Q(:,1)'];
        cutDir   = Q(:,2);
        radius   = radius(2);
    end
end
cutDir = cutDir(:)/norm(cutDir);
% also check that cutDir is meaningfull wrt coord
V = diff(segments, 1);
V = bsxfun(@rdivide, V, sqrt(dot(V,V,2)));
ip = V*cutDir;
if any(sign(ip(1)) ~= sign(ip))
%    error('Slicing direction is parallell to line segment')
end
% check options
if opt.outputForGridProcessing && opt.removeRepeated
    warning('Option ''removeRepeated'' reset to false since grid/n%s', ...
            'processing output was requested');
   opt.removeRepeated = false; 
end   
end

% -------------------------------------------------------------------------
%{
function fix = shapeSubset(G, fix, seg, cutDir, r) 
% distance to segment in cutDir-direction
orthSeg = [seg(1,:)-r*cutDir'; seg(1,:)+r*cutDir'];
fix = getFacesCloseToSegmentNew(G, orthSeg, 'projVec', diff(seg), 'faceIx', fix);
end
%}

% -------------------------------------------------------------------------
function [p, t, removed, clamped] = clampSides(p, seg, r, cutDir, n, isFirst, isLast, deleteOutside)
% clamp point p to t-endpoint te: p->p+(te-v.p)v
removed = false;
clamped = false(size(p,1), 1);
segProj = seg - (seg*cutDir)*cutDir';
v  = diff(segProj)';
l  = norm(v);
vu = v/l;
t = p*vu - segProj(1,:)*vu;
ixf = t < -sqrt(eps);
if isFirst
    % project along v to t = 0
    p(ixf,:) = p(ixf,:) - t(ixf)*vu';
    t(ixf)   = 0;
    clamped = clamped | ixf;
else
    removed = removed | ixf;
end
ixl = t > l+sqrt(eps);
if isLast
    % project along v to t = l
    p(ixl,:) = p(ixl,:) - (t(ixl)-l)*vu';
    t(ixl)   = l;
    clamped = clamped | ixl;
else
    removed = removed | ixl;
end
% t is length along segments, hence scale from segProj -> seg
t = (norm(diff(seg))/norm(v))*t;
% for finite r, project along cutDir
if ~isempty(r) && isfinite(r)
    % r in cutDir - direction
    % first find normal distance to segment
    v  = diff(seg)';
    v  = v/norm(v);
    vn = null([v'; n']);
    % find d s.t p + d*vn = seg(1,:) + t*v
    d = p*vn - seg(1,:)*vn;
    % find corresonding length along cutDir
    l = d/(cutDir'*vn);
    ix = abs(l) > r;
    if ~deleteOutside
        p(ix,:) = p(ix,:) - (l(ix) - sign(l(ix))*r)*cutDir';
    else
        removed = removed | ix;
    end
end
if any(removed)
    p = p(~removed,:);
    t = t(~removed);
    if any(clamped)
        clamped = clamped(~removed);
    end
end
end

% -------------------------------------------------------------------------
function [p ,t, removed, clamped] = clampEllipsoid(p, seg, r2, cutDir, deleteOutside)
% center at the middle of the segment
c  = mean(seg);
v  = diff(seg);
vu = v(:)/norm(v);
removed = false;
clamped = false(size(p,1), 1);
if ~isempty(r2) && isfinite(r2)
    r1 = norm(v)/2;
    pc = bsxfun(@minus, p, c);
    
    X  = [vu, cutDir];
    p2 = pc*X;
    tmp   = (p2(:,1)/r1).^2 + (p2(:,2)/r2).^2;
    scale = 1./sqrt(tmp);
    ix = scale < 1;
    if ~deleteOutside
        shift = bsxfun(@times, p2(ix,:), 1-scale(ix));
        p(ix,:) = p(ix,:) - shift*X';
        clamped = ix;
    else
        p = p(~ix,:);
        removed = ix;
    end
end
% also get length along segment
t = p*vu - seg(1,:)*vu;
end

% -------------------------------------------------------------------------    
function [r, v] = getEllipse(n, r, Q)
% get radius and principle axis of cut-plane ellipse from 
% normal plane: n'*x = 0
% ellipsoid: || (Q'*x)./r || = 1
% change of variables:
% u -> (Q'*x)./r
% plane in u-system: m'*u = 0, m = (Q'*n).*r
m  = (Q'*n).*r(:);
% basis for plane in u-system
Qu = null(m');
% circle in u-space: Qu*[cos(t); sin(t)], 0<=t<=2pi
% maps to ellipse in x-space: V*[cos(t); sin(t)], 0<=t<=2pi, W = Q'*Dr*Qu 
Dr = diag(r(:));
W  = Q*Dr*Qu;
% find one extremum corresponding to one of the ellipse main axis
tmp = W'*W;
[w11, w12, w22] = deal(tmp(1,1), tmp(1,2), tmp(2,2));
% differentiate and set to zero to get theta
t  = atan2(2*w12, w11-w22)/2;
v1 = W*[cos(t);sin(t)];
v2 =  W*[cos(t+pi/2);sin(t+pi/2)];
r  = [norm(v1), norm(v2)];
v  = [v1/r(1), v2/r(2)];
end

%----------------------------------------------------------------------
%{
function pn = getPlaneNormal(G)
    if isfield(G.cells, 'normal')
        pn = G.cells.normal(1,:)';
    else
        % find normal of any cell
        if ~isfield(G.cells, 'volumes')
            G = computeGeometry(G);
        end
        [~, c] = max(G.cells.volumes);
        fNo = G.cells.facePos(c):(G.cells.facePos(c+1)-1);
        f   = G.cells.faces(fNo);
        v   = diff(G.faces.centroids(f,:));
        pn  = sum(cross(v(1:end-1,:), v(2:end,:),2));
        pn = pn(:)/norm(pn);
    end
end
%}