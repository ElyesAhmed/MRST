function [ wellSols, states, sim_report, opt, var ] = runGenericInjectionScenario( Gt, rock2D, seainfo, wellinfo, varargin )
% Run a generic CO2 injection scenario for an Atlas formation.
%
% SYNOPSIS:
%
%
% DESCRIPTION:
%   An injection scenario is set-up, run, and then optionally saved.
%   Multiple injection wells can be set, as well as water-producing wells.
%
%
% INPUTS:
%   Gt      - top grid as generated by getFormationTopGrid()
%   rock2D  - available rock properties
%   seainfo - all available sea information, including:
%               - seafloor_depth
%               - seafloor_temp
%               - temp_gradient
%   fminfo  - all available information about the formation fluids:
%               - water_density
%               - co2_density
%               - water_mu
%               - co2_mu
%               - res_sat_wat
%               - res_sat_co2
%   wellinfo - details about wells, including:
%               - wellCoords (in physical coords (X,Y))
%                     - inj well location(s)
%                     - prod well locations(s)
%               - inj_rate_MtperYr
%               - prod_rate_MtperYr
%               - inj_time (year), inj_steps
%               - prod_time (year), prod_steps
%               - mig_time (year), mig_steps

%
%
% PARAMETERS:
%   'pn'/pv - List of optional property names/property values:
%
%
% RETURNS:
%   
%
% SEE ALSO:
%   exploreSimulation


    gravity on;
    moduleCheck('ad-core');

    rhoCref = 760 * kilogram / meter ^3; % an (arbitrary) reference density

    opt.seafloor_depth    = seainfo.seafloor_depth; % kilometer
    opt.seafloor_temp     = seainfo.seafloor_temp;  % in Celsius
    opt.temp_gradient     = seainfo.temp_gradient;  % Celsius per kilometer
    
    opt.water_density   = seainfo.water_density;
    opt.co2_density     = seainfo.co2_density;
    opt.water_mu        = seainfo.water_mu;
    opt.co2_mu          = seainfo.co2_mu;
    opt.res_sat_wat     = seainfo.res_sat_wat;
    opt.res_sat_co2     = seainfo.res_sat_co2;
    
    opt.water_compr_val = 4.3e-5/barsa;
    opt.pvMult          = 1e-5/barsa;
    
    opt.isDissOn        = false;
    opt.dis_max         = (53 * kilogram / meter^3) / rhoCref;

    
    opt.wellCoords_inj    = wellinfo.wellCoords_inj; % physical coords (X,Y)
    opt.wellCoords_prod   = wellinfo.wellCoords_prod;
    opt.well_radius       = 0.3;
    
    opt.inj_rate_MtperYr  = 5; %wellinfo.inj_rate_MtperYr;     % Mt/yr
    opt.inj_time          = 50*year; %wellinfo.inj_time;
    opt.inj_steps         = 10; %wellinfo.inj_steps;
    
    opt.prod_rate_MtperYr = 1; %wellinfo.prod_rate_MtperYr;
    opt.prod_time         = opt.inj_time; %wellinfo.prod_time;
    opt.prod_steps        = opt.inj_steps; %wellinfo.prod_steps;
    
    opt.mig_time          = 0; %wellinfo.mig_time;
    opt.mig_steps         = 0; %wellinfo.mig_steps;
    

    opt.bdryType          = 'pressure';

    opt = merge_options(opt, varargin{:});
    
    % rates in m3/s
    opt.inj_rate          = (opt.inj_rate_MtperYr * mega * kilo / rhoCref) / year; % m3/s
    opt.prod_rate         = (opt.prod_rate_MtperYr * mega * kilo / opt.water_density) / year; % m3/s
    

    %% Set-up (initial state, well location, schedule)
    
    % pressure and temperature
    initState.pressure  = Gt.cells.z * norm(gravity) * opt.water_density;   % hydrostatic pressure, in Pa=N/m^2
    initState.s         = repmat([1 0], Gt.cells.num, 1);                   % sat of water is 1, sat of CO2 is 0
    initState.sGmax     = initState.s(:,2);                                 % max sat of CO2 is initially 0
    initState.rs        = 0 * initState.sGmax;                              % initially 0   
    var.ref_p               = mean(initState.pressure);
    var.caprock_temperature = 273.15 + opt.seafloor_temp + ...
        (Gt.cells.z - opt.seafloor_depth) / 1e3 * opt.temp_gradient; % Kelvin

    
    % Set up wells:
    allWells = [opt.wellCoords_inj; opt.wellCoords_prod];
    allRates = [repmat( opt.inj_rate,  size(opt.wellCoords_inj), 1 ); ...
                repmat( -opt.prod_rate, size(opt.wellCoords_prod),1 ) ];
    numWells = size(allWells,1);
    for i = 1:numWells
        
        % Cell index(es) of well point(s) in top grid formation
        var.wellCellIndex(i)  = getCellIndex(Gt, allWells(i,1), allWells(i,2));
        var.wellCoordSim(i,1) = Gt.cells.centroids(var.wellCellIndex(i),1);
        var.wellCoordSim(i,2) = Gt.cells.centroids(var.wellCellIndex(i),2);

        % Put injection/producer wells into schedule.control(1)
        
        schedule.control(1).W(i) = addWell([], Gt.parent, rock2D, var.wellCellIndex(i), ...
            'name',     sprintf('W%i', var.wellCellIndex(i)),  ...
            'Type',     'rate', ...
            'Val',      allRates(i), ...
            'comp_i',   [0 1] );
        
        
        % Put turned-off wells into schedule.control(2)
        % or, use 'status',0 to implement turned-off wells?
        schedule.control(2).W(i)  = addWell([], Gt.parent, rock2D, var.wellCellIndex(i), ...
            'name',     [sprintf('W%i', var.wellCellIndex(i)) '_off'],  ...
            'Type',     'rate', ...
            'Val',      0, ...
            'comp_i',   [0 1] );
        
    end

    % Set up boundary conditions, and put into schedule.control(1) and schedule.control(2):
    bdryFaces   = find( Gt.faces.neighbors(:,1).*Gt.faces.neighbors(:,2) == 0 );
    bdryVal     = Gt.faces.z(bdryFaces) * opt.water_density * norm(gravity);
    bc          = addBC( [], bdryFaces, opt.bdryType, bdryVal, 'sat', [1 0] );
    for i = 1:numel(schedule.control)
        schedule.control(i).bc = bc;
    end
    
    % Set up time step, and put into schedule.step.control and schedule.step.val:
    % schedule.step.control links to the well controls, 1 or 2.
    dTi         = opt.inj_time / opt.inj_steps;
    dTm         = opt.mig_time / opt.mig_steps;
    istepvec    = ones(opt.inj_steps, 1) * dTi;
    mstepvec    = ones(opt.mig_steps, 1) * dTm;
    schedule.step.val       = [istepvec; mstepvec];
    schedule.step.control   = [ones(opt.inj_steps, 1); ones(opt.mig_steps, 1) * 2];
    
    

    %% Main parts of model and solver
    
    var.fluid = makeVEFluid(Gt, rock2D, 'sharp interface', ...
                                  'fixedT'      , var.caprock_temperature, ...
                                  'wat_mu_ref'  , opt.water_mu, ...
                                  'co2_mu_ref'  , opt.co2_mu, ...
                                  'wat_rho_ref' , opt.water_density, ...
                                  'co2_rho_ref' , opt.co2_density, ...
                                  'wat_rho_pvt' , [opt.water_compr_val, var.ref_p], ...
                                  'pvMult_p_ref', var.ref_p, ...
                                  'pvMult_fac'  , opt.pvMult, ...
                                  'residual'    , [opt.res_sat_wat, opt.res_sat_co2] , ...
                                  'dissolution' , opt.isDissOn, 'dis_max', opt.dis_max);
    var.model = CO2VEBlackOilTypeModel(Gt, rock2D, var.fluid);

    fprintf('\n\n Proceeding to solver... \n\n')
    [wellSols, states, sim_report] = simulateScheduleAD(initState, var.model, schedule);


end


function cellIndex = getCellIndex(Gt, Xcoord, Ycoord)
% Closest cell index of grid Gt corresponding to physical coordinate (X,Y)

    dv        = bsxfun(@minus, Gt.cells.centroids(:,1:2), [Xcoord, Ycoord]);
    [v, ind]  = min(sum(dv.^2, 2));
    cellIndex = ind; 
    % or Gt.cells.indexMap(i);
    
end

