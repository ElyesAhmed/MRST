function [ wellSols, states, sim_report, opt, var ] = ...
    runGenericInjectionScenario( Gt, rock2D, seainfo, wellinfo, varargin )
% Run a generic CO2 injection scenario for an Atlas formation.
%
% SYNOPSIS:
%
%
% DESCRIPTION:
%   An injection scenario is set-up, run, and then optionally saved.
%   Multiple injection wells can be set, as well as water-producing wells.
%
%
% INPUTS:
%   Gt      - top grid as generated by getFormationTopGrid()
%   rock2D  - available rock properties
%   seainfo - all available sea information, including:
%               - seafloor_depth
%               - seafloor_temp
%               - temp_gradient
%               - water_density
%               - co2_density
%               - water_mu
%               - co2_mu
%               - res_sat_wat
%               - res_sat_co2
%   wellinfo - details about wells, including:
%               - wellCoords (in physical coords (X,Y))
%                     - inj well location(s)
%                     - prod well locations(s)
%               - inj_rate_MtperYr
%               - prod_rate_MtperYr
%               - inj_time (year), inj_steps
%               - prod_time (year), prod_steps
%               - mig_time (year), mig_steps

%
%
% PARAMETERS:
%   'pn'/pv - List of optional property names/property values:
%       'bdryType' - could be 'pressure' or 'flux'
%
%
% RETURNS:
%   
%
% SEE ALSO:
%   exploreSimulation


    gravity on;
    moduleCheck('ad-core');

    %rhoCref = 760 * kilogram / meter ^3; % an (arbitrary) reference density
    rhoCref = seainfo.rhoCref;

    opt.seafloor_depth    = seainfo.seafloor_depth; % kilometer
    opt.seafloor_temp     = seainfo.seafloor_temp;  % in Celsius
    opt.temp_gradient     = seainfo.temp_gradient;  % Celsius per kilometer
    
    opt.water_density   = seainfo.water_density;
    opt.co2_density     = seainfo.co2_density;
    opt.water_mu        = seainfo.water_mu;
    opt.co2_mu          = seainfo.co2_mu;
    opt.res_sat_wat     = seainfo.res_sat_wat;
    opt.res_sat_co2     = seainfo.res_sat_co2;
    
    opt.water_compr_val = 4.3e-5/barsa;
    opt.pvMult          = 1e-5/barsa;
    
    opt.isDissOn        = false;
    opt.dis_max         = seainfo.dis_max;

   
    opt.well_radius       = 0.3;
    
    %%% Injection info:
    opt.wellCoords_inj    = wellinfo.wellCoords_inj; % physical coords (X,Y)
    opt.inj_time          = 50*year;
    opt.inj_steps         = 10;
    if isfield(wellinfo,'inj_rate_MtperYr')
        assert(numel(opt.wellCoords_inj,2) == numel(wellinfo.inj_rate_MtperYr))
        opt.inj_rate_MtperYr  = wellinfo.inj_rate_MtperYr;     % Mt/yr
    elseif isfield(wellinfo,'vols_inj')
        opt.inj_rate_MtperYr  = wellinfo.vols_inj ./ convertTo(opt.inj_time,year) .* opt.co2_density ./ 1e9; % Mt/yr
    end

    %%% Production info:
    opt.wellCoords_prod   = [];
    opt.prod_time         = [];
    opt.prod_steps        = [];
    opt.prod_rate_MtperYr = [];
    if isfield(wellinfo,'wellCoords_prod')
        opt.wellCoords_prod   = wellinfo.wellCoords_prod;
        opt.prod_time         = opt.inj_time;
        opt.prod_steps        = opt.inj_steps;
        if isfield(wellinfo,'prod_rate_MtperYr')
            assert(numel(opt.wellCoords_prod,2) == numel(wellinfo.prod_rate_MtperYr))
            opt.prod_rate_MtperYr = wellinfo.prod_rate_MtperYr;
        elseif isfield(wellinfo,'vols_prod')
            opt.prod_rate_MtperYr = wellinfo.vols_prod ./ convertTo(opt.prod_time,year) .* opt.water_density;
        else
            opt.prod_rate_MtperYr = repmat( mean(opt.inj_rate_MtperYr)/10, [1, numel(opt.wellCoords_prod,2)]);
        end
    end
    
    opt.mig_time          = 3000*year;
    opt.mig_steps         = 30;
    

    opt.bdryType          = 'pressure'; % initialization only
    opt.transMult         = [];         % transmissibilities of faultFaces will be modified if transMult is specified.
    opt.faultFaces        = [];

    opt = merge_options(opt, varargin{:});
    
    % reservoir volumetic rates in m3/s
    % use rhoCref or co2.rho(p,t) or co2_density?
    opt.inj_rate          = (opt.inj_rate_MtperYr .* mega .* kilo ./ opt.co2_density) ./ year; % m3/s
    opt.prod_rate         = (opt.prod_rate_MtperYr .* mega .* kilo ./ opt.water_density) ./ year; % m3/s
    
    figure
    bar(opt.inj_rate)
    ylabel('Injection rates (m^3/s)')
    
    if ~isempty(opt.transMult)
        update_transmissibilities = true;
        assert( ~isempty(opt.faultFaces), 'When you specify a transmissibility multiplier, you must also specify the fault face indices.')
    else
        update_transmissibilities = false;
    end

    %% Set-up (initial state, well location, schedule)
    
    % pressure and temperature
    initState.pressure  = Gt.cells.z * norm(gravity) * opt.water_density;   % hydrostatic pressure, in Pa=N/m^2
    initState.s         = repmat([1 0], Gt.cells.num, 1);                   % sat of water is 1, sat of CO2 is 0
    initState.sGmax     = initState.s(:,2);                                 % max sat of CO2 is initially 0
    initState.rs        = 0 * initState.sGmax;                              % initially 0   
    var.ref_p               = mean(initState.pressure);
    var.caprock_temperature = 273.15 + opt.seafloor_temp + ...
        (Gt.cells.z - opt.seafloor_depth) / 1e3 * opt.temp_gradient; % Kelvin

    
    % Set up wells:
    % NB: reference depth is supplied here when adding well. If Gt.parent
    % is used to set up well, supply reference depth of
    % Gt.parents.cells.centroid(wellCellIndex,3). If Gt is used, ref depth
    % is Gt.cells.z(wellCellIndex), but it might not be necessary to supply
    % it explicitly.
    allWells = [opt.wellCoords_inj; opt.wellCoords_prod];
    %allRates = [repmat( opt.inj_rate,  [size(opt.wellCoords_inj), 1] ); ...
    %            repmat( -opt.prod_rate, [size(opt.wellCoords_prod), 1] ) ];
    allRates = [ opt.inj_rate; -opt.prod_rate ];
    numWells = size(allWells,1);
    W = [];
    for i = 1:numWells
        
        % Cell index(es) of well point(s) in top grid formation
        var.wellCellIndex(i)  = getCellIndex(Gt, allWells(i,1), allWells(i,2));
        var.wellCoordSim(i,1) = Gt.cells.centroids(var.wellCellIndex(i),1);
        var.wellCoordSim(i,2) = Gt.cells.centroids(var.wellCellIndex(i),2);

        % Assign well name (to distinguish inj vs. prod)
        if allRates(i) > 0
            % inj
            wellname = sprintf('Winj%i', var.wellCellIndex(i));
            composition = [0 1];
        else
            % prod
            wellname = sprintf('Wprd%i', var.wellCellIndex(i));
            composition = [1 1];
        end
        
        
        % Put injection/producer wells into schedule.control(1):
        % if 3D exists, addWell + convertwellsVE() is used, otherwise
        % 2D is used to create W, and then W.dZ is manually set to 0 and
        % W.WI is corrected (st it corresponds to well cell column area,
        % not area of top grid well cell)
        % NB: whether 'refDepth' is zero or otherwise, results appear to be
        % the same.
        if isfield(Gt,'parent')
            W = addWell(W, Gt.parent, rock2D, var.wellCellIndex(i), ...
                'name',     wellname,  ...
                'Type',     'rate', ...
                'Val',      allRates(i), ...
                'comp_i',   composition, ...
                'refDepth', Gt.parent.cells.centroids(var.wellCellIndex(i),3) );
            %W = convertwellsVE(W, Gt.parent, Gt, rock2D, 'ip_tpf'); % do
            %outside for loop since additional field is added to W, which
            %causes number of fields in structure W not to match.
            
            %alternative: convertwellsVE_s()
            %  (however, may compute WI differently, won't contain h, and
            %  won't use the user specified 'refDepth')
            %W = convertwellsVE_s(W, Gt.parent, Gt, rock2D, 'ip_tpf');
            
        else
            W = addWell(W, Gt, rock2D, var.wellCellIndex(i), ...
                'name',     wellname,  ...
                'Type',     'rate', ...
                'Val',      allRates(i), ...
                'comp_i',   composition, ...
                'refDepth', Gt.cells.z(var.wellCellIndex(i)) + Gt.cells.H(var.wellCellIndex(i))./2 );
            W(i).dZ = 0;
            W(i).WI = W(i).WI .* Gt.cells.H(var.wellCellIndex(i));

        end
         

    end
    
    if isfield(Gt,'parent')
        W = convertwellsVE(W, Gt.parent, Gt, rock2D, 'ip_tpf');
    end
    
      % Turn-off well rates for control(2)
      W_shut = W;
      for i = 1:numel(W_shut)
         W_shut(i).val = 0;
      end
      
      schedule.control(1).W = W;
      schedule.control(2).W = W_shut;
      
      

    % Set up boundary conditions, and put into schedule.control(1) and schedule.control(2):
    bdryFaces   = find( Gt.faces.neighbors(:,1).*Gt.faces.neighbors(:,2) == 0 );
    if strcmpi(opt.bdryType,'pressure')
        bdryVal     = Gt.faces.z(bdryFaces) * opt.water_density * norm(gravity);
    elseif strcmpi(opt.bdryType,'flux')
        bdryVal     = zeros(numel(bdryFaces),1);
        % does saturation bdry change?
    end
    bc          = addBC( [], bdryFaces, opt.bdryType, bdryVal, 'sat', [1 0] );
    for i = 1:numel(schedule.control)
        schedule.control(i).bc = bc;
    end
    
    % Set up time step, and put into schedule.step.control and schedule.step.val:
    % schedule.step.control links to the well controls, 1 or 2.
    dTi         = opt.inj_time / opt.inj_steps;
    dTm         = opt.mig_time / opt.mig_steps;
    istepvec    = ones(opt.inj_steps, 1) * dTi;
    mstepvec    = ones(opt.mig_steps, 1) * dTm;
    schedule.step.val       = [istepvec; mstepvec];
    schedule.step.control   = [ones(opt.inj_steps, 1); ones(opt.mig_steps, 1) * 2];
    
    

    %% Main parts of model and solver
    % @@ what parts of makeVEFluid, Model, simulateScheduleAD, will use
    % rock2D.ntg if field exists?
    
    var.fluid = makeVEFluid(Gt, rock2D, 'sharp interface', ...
                                  'fixedT'      , var.caprock_temperature, ...
                                  'wat_mu_ref'  , opt.water_mu, ...
                                  'co2_mu_ref'  , opt.co2_mu, ...
                                  'wat_rho_ref' , opt.water_density, ...
                                  'co2_rho_ref' , opt.co2_density, ...
                                  'wat_rho_pvt' , [opt.water_compr_val, var.ref_p], ...
                                  'pvMult_p_ref', var.ref_p, ...
                                  'pvMult_fac'  , opt.pvMult, ...
                                  'residual'    , [opt.res_sat_wat, opt.res_sat_co2] , ...
                                  'dissolution' , opt.isDissOn, 'dis_max', opt.dis_max);
    
    var.model = CO2VEBlackOilTypeModel(Gt, rock2D, var.fluid);
    
    if update_transmissibilities
        T_all                   = getVerticallyAveragedTrans(Gt, rock2D);
        T_all_orig              = T_all;
        T_all( opt.faultFaces ) = T_all( opt.faultFaces ).*opt.transMult;
        var.model.operators.T_all  = T_all;
        var.model.operators.T      = T_all( var.model.operators.internalConn );
    end
    

    fprintf('\n\n Proceeding to solver... \n\n')
    [wellSols, states, sim_report] = simulateScheduleAD(initState, var.model, schedule);
    var.initState = initState;
    var.schedule  = schedule;

end


function cellIndex = getCellIndex(Gt, Xcoord, Ycoord)
% Closest cell index of grid Gt corresponding to physical coordinate (X,Y)

    dv        = bsxfun(@minus, Gt.cells.centroids(:,1:2), [Xcoord, Ycoord]);
    [v, ind]  = min(sum(dv.^2, 2));
    cellIndex = ind; 
    % or Gt.cells.indexMap(i);
    
end

